<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://use.typekit.net/ezo4zbn.css">
<style type="text/css">
body {
  margin: 20px;
  font-family: acumin-pro-condensed, arial, sans;
  line-height: 1.3em;
  width: 1180px;
}

h3 {
  margin: 0 0 4px 4px;
  line-height: 1.05em;
}

.label {
  font-size: 18px;
}

.legend{
  opacity: 1;
  transition: opacity 0.3s;
}

.axis text {
  font-size: 14px;
  fill: #333;
}

.axis path,
.axis line {
  fill: none;
  stroke-width:1px;
  stroke: #e7e7e7;
}

circle {
  stroke: #fff;
  stroke-width: 1px;
  opacity: 0.8;
}

.bubble {
  opacity: 1;
  transition: opacity 0.3s;
}

path.country {
  opacity: 1;
  transition: opacity 0.3s;
}

.stroke {
  fill: none;
  stroke: #bbb;
  stroke-width: 2px;
}

.fill {
  fill: #fff;
}

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: 0.5px;
  stroke-opacity: 0.5;
}

.land {
  fill: #ddd;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
}
.checkbox {
  width: 20
}

#year-slider {
  margin: 0 0px 0 0;
}
.year-label{
  font-weight:bold;
  font-size:26;
}
.country-label{
  font-weight:bold;
  font-size:26;
}

#controls {
  border: 1px solid #d0d0d0;
  display: inline-block;
  padding: 8px 16px;
  font-size: 18px;
}
</style>

<body>
  <div id='header'>
  <h1>Exploring Country-level GHG-GDP Divergence --test79--</h1>
  </div>

  <div id='info_and_controls'>
    <div id='controls'>
      <div id='info'>
        <p> Use this tool to explore the relationship between economic growth (GDP) and carbon emissions around the world </p>
      </div>
      Time Range &nbsp;
      <input type="range" min=2000 max=2016 step=1 value=2000 id="year-slider" />
      <text class="year-label">1999-2000</text>
      Autoplay?
      <input type="checkbox" class="checkbox autoplay_checkbox" checked />
      Mouseover lock?
      <input type="checkbox" class="checkbox mouseover_checkbox" />
      Production emissions?
      <input type="checkbox" class="checkbox emissions_prod_checkbox" checked />
      Percent changes?
      <input type="checkbox" class="checkbox measurement_change_checkbox" checked />

    </div>
    <div id='graphs_and_labels'>
      <br/>
      <div class='header_labels'>
        <text class='country-label'>World</text>
        <text class='active_x_metric-label'>Gross Domestic Product Change</text>
        <text class='active_x_metric-value'></text>
        <text>/</text>
        <text class='active_y_metric-label'>Production Emissions Change</text>
        <text class='active_y_metric-value'></text>
      </div>
    </div>
  </div>

  <div id='map_and_scatter'></div>

  <div id='explainer_section'>
    Demonstrate how colors are given
  </div>

</body>

<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

<script>

/// FLOW AND STATE CONTROL

var playing = true;
var next_year_in_progress = false;
var year = 2000;
var change_or_raw = 'change';
var prod_or_cons = 'prod';
var color_by_z = false;

/// VARIABLES COVERED AND TEXT FORMATTING

var co2_prod_change = "Production CO2 Emissions Annual Change";
var co2_cons_change = "Consumption CO2 Emissions Annual Change"
var gdp_change = "GDP percent change";

var co2_prod_raw = "Production CO2 Emissions Absolute Value";
var co2_cons_raw = "Consumption CO2 Emissions Absolute Value";
var gdp_raw = "GDP";

var active_x_metric = gdp_change
var active_y_metric = co2_prod_change
var radius_metric = co2_prod_raw

var mean = {}
var sd = {}

var clicked_country = null;
var selected_country = "WLD";
var exclude = ["AFG", "COD", "LBY", "LCA", "LIE", "LSO", "MCO", "MDA", "NRU", "PRK", "ROU", "SMR", "SOM", "SSD", "SYR", "TLS", "TUV", "WLD"];

var format = d3.format(".0%");
var default_format = d3.format(",.2r");
var format_si = d3.format(".2s");
function format_abbrev(x) {
  var s = format_si(x);
  switch (s[s.length - 1]) {
    case "G": return s.slice(0, -1) + "B";
  }
  return s;
}

var metric_lookup = {
  "Production CO2 Emissions Annual Change": {
    "key": "Production CO2 Emissions Annual Change",
    "name": "Production Emissions Change",
    "units": "Mt C",
    "scale": 'generated on data load',
    "format": format,
    "extent": [-0.5,.5],
    "longextent": [-0.5,3]
  },
  "Production CO2 Emissions Absolute Value": {
    "key": "Production CO2 Emissions Absolute Value",
    "name": "Production Emissions",
    "units": "Mt C",
    "scale": 'generated on data load',
    "format": default_format,
    "extent": [0,3000],
    "longextent": [-50,300]
  },

  "Consumption CO2 Emissions Annual Change": {
    "key": "Consumption CO2 Emissions Annual Change",
    "name": "Consumption Emissions Change",
    "units": "Mt C",
    "scale": 'generated on data load',
    "format": format,
    "extent": [-.5,.5],
    "longextent": [-0.5,4]
  },
  "Consumption CO2 Emissions Absolute Value": {
    "key": "Consumption CO2 Emissions Absolute Value",
    "name": "Consumption Emissions",
    "units": "Mt C",
    "scale": 'generated on data load',
    "format": default_format,
    "extent": [0,2500],
    "longextent": [-100,500]
  },

  "GDP percent change": {
    "key": "GDP percent change",
    "name": "Gross Domestic Product Change",
    "units": "constant 2010 US$",
    "scale": 'generated on data load',
    "format": format,
    "extent": [-0.5,1],
    "longextent": [-.1,11]
  },
  "GDP": {
    "key": "GDP",
    "name": "Gross Domestic Product",
    "units": "constant 2010 US$",
    "scale": 'generated on data load',
    "format": format_si,
    "extent": [6e7,2e13],
    "longextent": [-1e12,3e12]
  }
}

/// CONTAINERS

var margin = { top: 50, right: 20, bottom: 50, left: 50 };
var scatter_width = 530 - margin.left - margin.right;
var scatter_height = 560 - margin.top - margin.bottom;
var map_width = 620;
var map_height = 560;

var scatter_svg = d3.select("#map_and_scatter")
  .append("svg")
    .attr("width", scatter_width + margin.left + margin.right)
    .attr("height", scatter_height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var map_container = d3.select("#map_and_scatter")
  .append("div")
    .style("width", map_width + "px")
    .style("height", map_height + "px")
    .style("position", "relative")
    .style("display", "inline-block");

var map_svg = map_container
  .append("svg")
    .attr("width", map_width)
    .attr("height", map_height);

/// CHECKBOXES

d3.selectAll(".mouseover_checkbox")
.on("change", function () {
    if(this.checked){
      clicked_country = selected_country;
    } else {
      clicked_country = null;
    }
});

d3.selectAll(".autoplay_checkbox")
.on("change", function () {
    if(this.checked){
      playing = true;
      if(currentTimeout){
        clearTimeout(currentTimeout)
        nextYear();
      }
      return;
    } else {
      playing = false;
      if(currentTimeout){
        clearTimeout(currentTimeout)
      }
      return;
    }
});

d3.selectAll(".emissions_prod_checkbox")
.on("change", function () {
    if(this.checked){
      // Show production emissions
      prod_or_cons = 'prod'
      if(change_or_raw == 'change') {
        active_y_metric = co2_prod_change
      } else {
        active_y_metric = co2_prod_raw
      }
      radius_metric = co2_prod_raw
    } else {
      prod_or_cons = 'cons'
      if(change_or_raw == 'change') {
        active_y_metric = co2_cons_change
      } else {
        active_y_metric = co2_cons_raw
      }
      radius_metric = co2_cons_raw
    }
    updateAxes();
    transition_scatter_and_map();
    update_labels();
    return;
});

d3.selectAll(".measurement_change_checkbox")
.on("change", function () {
    if(this.checked){
      // Show change in measurement
      change_or_raw = 'change'
      color_by_z = false
      if(prod_or_cons == 'prod'){
        // Production emissions selected
        active_y_metric=co2_prod_change
      } else {
        // Consumption emissions selected
        active_y_metric=co2_cons_change
      }
      active_x_metric = gdp_change
    } else {
      // Show absolute value of measurement
      change_or_raw = 'raw'
      color_by_z = true
      if(prod_or_cons == 'prod'){
        // Production emissions selected
        active_y_metric=co2_prod_raw
      } else {
        // Consumption emissions selected
        active_y_metric=co2_cons_raw
      }
      active_x_metric = gdp_raw
    }
    updateAxes();
    transition_scatter_and_map();
    update_labels();
    return;
});

/// SCALES, AXES, COLORS

/*
var xscale = d3.scaleLinear()
  .domain([-0.5,0.5])
  .range([0,scatter_width])
  .clamp("true");

var yscale = d3.scaleLinear()
  .domain([-0.5,0.5])
  .range([scatter_height,0])
  .clamp("true");
*/

var radius = d3.scaleSqrt()
  .domain([0, 3000])
  .range([2.5,20]);

function colorWrapper(y,x){
  if(x==0) {x = .0000000001}

  if(color_by_z){
    x = standardize(x, active_x_metric)
    y = standardize(y, active_y_metric)
  }

  var val = Math.atan(y/x)
  val = val*180/Math.PI
  if(x>0){
    return(colorMapPosX(val))
  }else{
    return(colorMapNegX(val))
  }
}

var colorMapPosX = d3.scaleLinear()
  .domain([-135,-45,45,135])
  .range(["white","blue","white","red"]);
var colorMapNegX = d3.scaleLinear()
  .domain([-135,-45,45,135])
  .range(["white","red","white","blue"]);

function standardize(val, metric){
  return((val - mean[metric][year])/sd[metric][year])
}

/*
var xAxis = d3.axisBottom()
  .tickSize(-scatter_height)
  .tickFormat(function(d) {
    return format(d);
  })
  .scale(xscale);

var yAxis = d3.axisLeft()
  .tickFormat(function(d) {
    return format(d);
  })
  .tickSize(-scatter_width)
  .scale(yscale)
*/

function updateAxes(){
  updateXAxis()
  updateYAxis()
}

function updateXAxis() {
  xscale = metric_lookup[active_x_metric].scale;
  // for Summary ranges
  if (String(year).indexOf("Summary") > -1) {
    xscale.domain(metric_lookup[active_x_metric].longextent);
  } else {
    xscale.domain(metric_lookup[active_x_metric].extent);
  }
  var xAxis = d3.axisBottom()
    .tickSize(-scatter_width)
    .tickFormat(metric_lookup[active_x_metric].format)
    .scale(xscale);
  scatter_svg.select(".x.axis")
    .transition()
    .call(xAxis);
  d3.selectAll(".dark-line-1")
    .transition()
    .attr("x1", xscale(0))
    .attr("x2", xscale(0))
  scatter_svg.selectAll(".x.axis text")
    .transition()
    .attr("y", 8);
};

function updateYAxis(metric) {
  yscale = metric_lookup[active_y_metric].scale;
  // for 2000-2015 year ranges
  if (String(year).indexOf("Summary") > -1) {
    yscale.domain(metric_lookup[active_y_metric].longextent);
  } else {
    yscale.domain(metric_lookup[active_y_metric].extent);
  }
  var yAxis = d3.axisLeft()
    .tickSize(-scatter_height)
    .tickFormat(metric_lookup[active_y_metric].format)
    .scale(yscale);
  scatter_svg.select(".y.axis")
    .transition()
    .call(yAxis);
  d3.selectAll(".dark-line-2")
    .transition()
    .attr("y1", yscale(0))
    .attr("y2", yscale(0))
};

/// DRAWING THE MAP

var projection = d3.geoTimes()
    .scale((map_width - 4) / (1.5 * Math.PI))
    .translate([map_width / 2, map_height / 2])
    .precision(0.1);

var path = d3.geoPath()
    .projection(projection);

var graticule = d3.geoGraticule();

var idLookup = {};


map_svg.append("defs").append("path")
    .datum(graticule.outline())
    .attr("id", "sphere")
    .attr("d", path);

map_svg.append("use")
    .attr("class", "stroke")
    .attr("xlink:href", "#sphere");

map_svg.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");

map_svg.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);

/// LOAD DATA
var lookup = {};

d3.queue()
.defer(d3.csv, '../final-data/All\ Data\ Together\ Concise.csv')
  .await(function(error, all_data) {
    console.log(all_data)
    all_data.forEach(function(d) {
      lookup[d["ISO"]] = lookup[d["ISO"]] || {};
      lookup[d["ISO"]][d["Indicator"]] = d;
      lookup[d["ISO"]]["name"] = lookup[d["ISO"]]["name"] || d["Country Name"]
    });
  console.log(lookup)
  console.log(all_data)

  // Set scales for each metric
  Object.keys(metric_lookup).forEach(function(metric) {

    if (metric == gdp_raw || metric == gdp_change){
      metric_lookup[metric].scale = d3.scaleLinear().domain(metric_lookup[metric].extent).range([0,scatter_width]).clamp(true);
    } else {
      metric_lookup[metric].scale = d3.scaleLinear().domain(metric_lookup[metric].extent).range([scatter_height,0]).clamp(true);
    }

    mean[metric] = {}
    sd[metric] = {}
    // Calculate global mean and sd of each metric in each year
    for (i = 0; i < 16; i++){
      mean[metric][2000+i] = d3.mean(Object.keys(lookup), function(d) {
        if(metric in lookup[d] && (2000+i) in lookup[d][metric]){
          return lookup[d][metric][2000+i]
        } else {return null}
      })
      sd[metric][2000+i] = d3.deviation(Object.keys(lookup), function(d) {
        if(metric in lookup[d] && (2000+i) in lookup[d][metric]){
          return lookup[d][metric][2000+i]
        } else {return null}
      })
    }
    mean[metric]['Summary Range'] = d3.mean(Object.keys(lookup), function(d) {
      if(metric in lookup[d]){
        return lookup[d][metric]['Summary Range']
      } else {return null}
    })
    sd[metric]['Summary Range'] = d3.deviation(Object.keys(lookup), function(d) {
      if(metric in lookup[d]){
        return lookup[d][metric]['Summary Range']
      } else {return null}
    })

    console.log(mean)
    console.log(sd)
    /*
    var data = all_data.filter(function(d) { return d["Indicator"]==metric && d["ISO"] !== "WLD";})
    var year_cols = [...Array(1+2015-2000).keys()].map(v => 2000+v).map(u => String(u))
    var joined_data = []
    var year
    for (i = 0; i < year_cols.length; i++){
      year = year_cols[i]
      joined_data = joined_data.concat(d3.extent(data, function(d){return +d[year]}))
    }
    var calculated_extent = d3.extent(joined_data)
    var calculated_long_extent = d3.extent(data, function(d) { return +d["Summary Range"]; })
    var extent = metric_lookup[metric].extent = metric_lookup[metric].extent || calculated_extent;
    metric_lookup[metric].longextent = metric_lookup[metric].longextent || calculated_long_extent;
    */

  });


    // DRAW SCATTER

    var countries = d3.keys(lookup);
    scatter_svg.append("g")
      .attr("transform", "translate(0," + scatter_height + ")")
      .attr("class", "x axis");

    scatter_svg.selectAll(".x.axis text")
      .attr("y", 8);

    scatter_svg.append("g")
      .attr("transform", "translate(0,0)")
      .attr("class", "y axis");

    scatter_svg
      .append("line")
      .attr("class", "dark-line-1")
      .style("stroke", "#777")
      .style("stroke-width", 1)
      .attr("y1", 0)
      .attr("y2", scatter_height)
    scatter_svg
      .append("line")
      .attr("class", "dark-line-2")
      .style("stroke", "#777")
      .style("stroke-width", 1)
      .attr("x1", 0)
      .attr("x2", scatter_width)

    // All axes drawing occurs here
    updateAxes()

    var group = scatter_svg.selectAll("g.bubble")
      .data(countries.filter(function(d) {
        // only include those not in the exclude list
        return d && exclude.indexOf(d) == -1;
      }))
      .enter().append("g")
      .sort(function(a,b) {
        return +lookup[b][radius_metric][year].replace(",","") - (+lookup[a][radius_metric][year].replace(",",""));
      })
      .attr("class", "bubble")
      .attr("transform", function(d) {
        return "translate(" + xscale(+lookup[d][active_x_metric][year]) + "," + yscale(+lookup[d][active_y_metric][year]) + ")"
      });

    group
      .append("text")
      .attr("y", -20)
      .attr("text-anchor", "middle")
      .style("font-weight", "bold")
      .text(function(d) {
        return d in lookup ? lookup[d].name : "";
      })
      .style("display", "none");

    group
      .append("circle")
      .attr("r", function(d) {
        if (!(year in lookup[d][radius_metric])) { return 0 }
        if(String(year).indexOf("Summary") > -1){
          if(prod_or_cons == 'prod'){
            return radius(+lookup[d][radius_metric][2015].replace(",",""));
          } else {
            return radius(+lookup[d][radius_metric][2014].replace(",",""));
          }
        } else {
          return radius(+lookup[d][radius_metric][year].replace(",",""));
        }
      })
      .style("fill", function(d) {
        return "#777";
      })
      .on("click", function(d) {
        clicked_country = d
        d3.select(".mouseover_checkbox")
        .property("checked", true)
        update_to_selected_region(clicked_country);
      })
      .on("mouseover", function(d) {
        var country = d;
        if (clicked_country) {
          return clicked_country
        } else {
          if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
          if (!(country in lookup)) { return "#eaeaea"; }
          update_to_selected_region(country)
        }
      })
      .on("mouseout", function() {
        if (clicked_country) {
          return clicked_country;
        } else {
          reset_to_global()
        }
      })

    // DRAW MAP

    // With TopoJSON
/*
    isoLookup = {}
    d3.json("../data/wri-bounds-topo.json", function(error, world) {
      if (error) throw error;

      map_svg.selectAll("path.country")
          .data(topojson.feature(world, world.objects.countries).features)
        .enter().append("path")
          .attr("class", "country")
          .attr("d", path);

      map_svg.insert("path", ".graticule")
          .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
          .attr("class", "boundary")
          .attr("d", path);

      d3.csv("../data/iso-3166.csv", function(error, isoCodes) {
        isoCodes.forEach(function(d) {
          isoLookup[String(+d["country-code"])] = d;
        });

        setYear_updateData(2000);
        setTimeout(nextYear, 1100);
         console.log("set year and cued nextYear")

        map_svg.selectAll("path.country")
          .style("fill", function(d) {
            var country = isoLookup[d.id]['alpha-3']
            if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
            if (!(country in lookup)) { return "#eaeaea"; }
            var datum = lookup[country];
            if (datum[active_y_metric][year] == "") { return "#eaeaea" };
            if (datum[active_x_metric][year] == "") { return "#eaeaea" };
            return colorWrapper(datum[active_y_metric][year], datum[active_x_metric][year]) || "#eaeaea";
          })
          .on("click", function(d){
            clicked_country = isoLookup[d.id]['alpha-3'];
            d3.selectAll(".mouseover_checkbox")
             .property("checked", true)
            reset_to_global();
            update_to_selected_region(clicked_country)
          })
          .on("mouseover", function(d) {
            var country = isoLookup[d.id]['alpha-3']
            if (clicked_country) {
              return clicked_country;
            } else {
              if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
              if (!(country in lookup)) { return "#eaeaea"; }
              update_to_selected_region(country)
            }
          })
          .on("mouseout", function() {
            if (clicked_country) {
              return clicked_country;
            } else {
              reset_to_global();
            }
          });

      });
    });
*/

    //   Without using TopoJSON

    d3.json("../data/all_primary_countries.json", function(error, world){
      if (error) throw error;

      map_svg.selectAll("path.country")
        .data(world.features)
        .enter().append("path")
          .attr("class", "country")
          .attr("d", path);

        setYear_updateData(2000);
        setTimeout(nextYear, 1100);
         console.log("set year and cued nextYear")

        map_svg.selectAll("path.country")
          .style("fill", function(d) {
            var country = d.properties.iso_a3
            if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
            if (!(country in lookup)) { return "#eaeaea"; }
            var datum = lookup[country];
            if (datum[active_y_metric][year] == "") { return "#eaeaea" };
            if (datum[active_x_metric][year] == "") { return "#eaeaea" };
            return colorWrapper(datum[active_y_metric][year], datum[active_x_metric][year]) || "#eaeaea";
          })
          .on("click", function(d){
            clicked_country = d.properties.iso_a3;
            d3.selectAll(".mouseover_checkbox")
             .property("checked", true)
            reset_to_global();
            update_to_selected_region(clicked_country)
          })
          .on("mouseover", function(d) {
            var country = d.properties.iso_a3
            if (clicked_country) {
              return clicked_country;
            } else {
              if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
              if (!(country in lookup)) { return "#eaeaea"; }
              update_to_selected_region(country)
            }
          })
          .on("mouseout", function() {
            if (clicked_country) {
              return clicked_country;
            } else {
              reset_to_global();
            }
          });
    });

    // CREATE SLIDER
    d3.select("#year-slider")
      .on("input", function() {
        year = this.value;
        if (year == 2016) {
          year = "Summary Range"
          if(currentTimeout){
             next_year_in_progress = false;
             clearTimeout(currentTimeout);
          }
          setYear_updateData(year);
          return;
        }
        if(playing){
          if(currentTimeout){
             next_year_in_progress = false;
             clearTimeout(currentTimeout);
          }
          setYear_updateData(year);
          currentTimeout = setTimeout(nextYear, 1100);
          return;
        } else {
          if(currentTimeout){
             next_year_in_progress = false;
             clearTimeout(currentTimeout);
          }
          setYear_updateData(year);
        }
  });
});

/// HELPER FUNCTIONS

var currentTimeout;

function nextYear() {
  next_year_in_progress=true;
  if (!playing) {
    return;
  }
  if(String(year).indexOf("Summary") > -1){
    next_year_in_progress=false;
    return;
  }
  year++;
  if (year == 2016) {
    year = "Summary Range"
    setYear_updateData(year);
    next_year_in_progress=false;
    return;
  } else if(year < 2016) {
      setYear_updateData(year);
      currentTimeout = setTimeout(nextYear, 1100);
    return;
  }
};

function setYear_updateData(year) {
  var summary_period = true;
  if (String(year).indexOf("Summary") > -1) {
    summary_period = true;
    year = "Summary Range"
    //year_label.text(year);
    d3.select(".year-label").text(year)
    d3.select("#year-slider").node().value = 2016;
  } else {
    //year_label.text((year-1) + "-" + year);
    d3.select(".year-label").text((year-1) + "-" + year)
    d3.select("#year-slider").node().value = year;
  }
  updateAxes();
  transition_scatter_and_map();
  update_labels();
  style_map();
  style_circles();
}

function transition_scatter_and_map() {
  scatter_svg.selectAll("g.bubble")
    .transition()
    .duration(700)
    .style("opacity", function(d) {
      if (lookup[d][active_x_metric][year] == ""){return 0;}
      if (lookup[d][active_y_metric][year] == ""){return 0;}
      // Both metrics exist and are non-null
      return 0.8;
    })
    .attr("transform", function(d) {
      return "translate(" + xscale(+lookup[d][active_x_metric][year]) + "," + yscale(+lookup[d][active_y_metric][year]) + ")"
    });

  scatter_svg.selectAll("g.bubble circle")
    .transition()
    .duration(700)
    .attr("r", function(d) {
      if (!(year in lookup[d][radius_metric])) { return 0 }
      if(String(year).indexOf("Summary") > -1){
        if(prod_or_cons == 'prod'){
          return radius(+lookup[d][radius_metric][2015].replace(",",""));
        } else {
          return radius(+lookup[d][radius_metric][2014].replace(",",""));
        }
      } else {
        return radius(+lookup[d][radius_metric][year].replace(",",""));
      }
    })
    .style("fill", function(d) {
      if (lookup[d][active_y_metric][year] == "") { return "#eaeaea" };
      if (lookup[d][active_x_metric][year] == "") { return "#eaeaea" };
      return colorWrapper(lookup[d][active_y_metric][year], lookup[d][active_x_metric][year]) || "#eaeaea";
    })
  map_svg.selectAll("path.country")
    .transition(700)
    .style("fill", function(d) {
      var country = d.properties.iso_a3
      if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
      if (!(country in lookup)) { return "#eaeaea"; }
      var datum = lookup[country];
      if (datum[active_y_metric][year] == "") { return "#eaeaea" };
      if (datum[active_x_metric][year] == "") { return "#eaeaea" };
      return colorWrapper(datum[active_y_metric][year], datum[active_x_metric][year]) || "#eaeaea";
    })
}

function update_to_selected_region(region_name) {
    reset_to_global();
    selected_country = region_name
    style_map();
    console.log("Updated map")
    style_circles();
    console.log("Updated circles")
    update_labels();
    console.log("Updated labels")
}

function reset_to_global(){
    selected_country = "WLD";
    d3.select(".country-label").text("World");
    update_labels();
    map_svg.selectAll("path.country")
      .style("opacity", 1)
      .style("stroke", null);
    scatter_svg.selectAll(".bubble circle")
      .style("stroke", null)
      .style("stroke-width", null);
    scatter_svg.selectAll(".bubble text")
      .style("display", "none");
}

function update_labels(){
  datum = lookup[selected_country]

  country_name = datum.name
  d3.select(".country-label").text(country_name);

  d3.select(".active_x_metric-label")
    .text(metric_lookup[active_x_metric].name + ": ")
  d3.select(".active_y_metric-label")
    .text(metric_lookup[active_y_metric].name + ": ")

  if(active_x_metric in datum && year in datum[active_x_metric]){
    xval = +datum[active_x_metric][year]
    if(xval == ""){
      d3.select(".active_x_metric-value")
        .text("-- " + metric_lookup[active_x_metric].units);
    }else{
      d3.select(".active_x_metric-value")
        .text(metric_lookup[active_x_metric].format(xval) + " " + metric_lookup[active_x_metric].units);
    }
  } else {
    d3.select(".active_x_metric-value")
      .text("-- " + metric_lookup[active_x_metric].units);
  }

  if(active_y_metric in datum && year in datum[active_y_metric]){
    yval = +datum[active_y_metric][year]
    if(yval == ""){
      d3.select(".active_y_metric-value")
        .text("-- " + metric_lookup[active_y_metric].units);
    }else{
      d3.select(".active_y_metric-value")
        .text(metric_lookup[active_y_metric].format(yval) + " " + metric_lookup[active_y_metric].units);
    }
  } else {
    d3.select(".active_y_metric-value")
      .text("-- " + metric_lookup[active_y_metric].units);
  }

  //No world data for consumption emissions available, use production emissions instead
  if ((selected_country=='WLD') && ((active_y_metric == co2_cons_raw) || (active_y_metric == co2_cons_change))){
    if(active_y_metric == co2_cons_change){
      d3.select(".active_y_metric-value")
        .text(metric_lookup[co2_prod_change].format(+datum[co2_prod_change][year]) + " " + metric_lookup[co2_prod_change].units);
    } else {
      d3.select(".active_y_metric-value")
        .text(metric_lookup[co2_prod_raw].format(+datum[co2_prod_raw][year]) + " " + metric_lookup[co2_prod_raw].units);
    }
  }
};

function style_circles(){
  // Reset order
  scatter_svg.selectAll(".bubble")
     .sort(function(a,b) {
            return +lookup[b][radius_metric][year].replace(",","") - (+lookup[a][radius_metric][year].replace(",",""));
          })
  // Raise and highlight selected bubble
  var selected_bubble = scatter_svg.selectAll(".bubble")
    .filter(function(p) {
      return selected_country == p;
    })
    .raise()
  selected_bubble.select("circle")
    .style("stroke", "#111")
    .style("stroke-width", "2px");
  selected_bubble.select("text")
    .style("display", null);
}

function style_map(){
  if (selected_country=='WLD'){
    map_svg.selectAll("path.country")
      .style("opacity", 1)
      .style("stroke", null);
  }else{
    map_svg.selectAll("path.country")
      .style("opacity", function(p) {
        // for TopoJSON: return isoLookup[p.id]['alpha-3'] == String(selected_country) ? 1 : 0.3;
        return p.properties.iso_a3 == String(selected_country) ? 1 : 0.3;
      })
      .style("stroke", function(p) {
        // for TopoJSON: return isoLookup[p.id]['alpha-3'] == String(selected_country) ? "#222" : null;
        return p.properties.iso_a3 == String(selected_country) ? "#222" : null;
      });
  }
}

</script>
