<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://use.typekit.net/ezo4zbn.css">
<style type="text/css">
body {
  margin: 20px;
  font-family: acumin-pro-condensed, arial, sans;
  line-height: 1.3em;
  width: 1180px;
}

h3 {
  margin: 0 0 4px 4px;
  line-height: 1.05em;
}

.label {
  font-size: 18px;
}

.legend{
  opacity: 1;
  transition: opacity 0.3s;
}

.axis text {
  font-size: 14px;
  fill: #333;
}

.axis path,
.axis line {
  fill: none;
  stroke-width:1px;
  stroke: #e7e7e7;
}

circle {
  stroke: #fff;
  stroke-width: 1px;
  opacity: 0.8;
}

.bubble {
  opacity: 1;
  transition: opacity 0.3s;
}

path.country {
  opacity: 1;
  transition: opacity 0.3s;
}

.stroke {
  fill: none;
  stroke: #bbb;
  stroke-width: 2px;
}

.fill {
  fill: #fff;
}

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: 0.5px;
  stroke-opacity: 0.5;
}

.land {
  fill: #ddd;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: 0.5px;
}
#tooltip {
  width: 480px;
  padding: 6px 12px;
}
#tooltip h3 {
  margin: 0 0 12px 0;
}

#year-slider {
  margin: 0 0px 0 0;
}
</style>

<body>
<h1>Exploring Country-level GHG-GDP Divergence --test47--</h1>
<div style="border: 1px solid #d0d0d0; display: inline-block; padding: 8px 16px; font-size: 18px;">
  Time Range &nbsp;
  <input type="range" min=2000 max=2016 step=1 value=2000 id="year-slider" style="width: 200px">
  Autoplay? &nbsp;
  <input type="checkbox" class="autoplay_checkbox" checked style="width: 200px">
  Mouseover lock? &nbsp;
  <input type="checkbox" class="mouseover_checkbox" style="width: 200px">

</div><br/>
</body>

<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>

<script>

var playing = true;
var next_year_in_progress = false;
var year = 2000;
var active_metric = "Production CO2 Emissions Annual Change";
var active_ymetric = "GDP percent change";
var clicked_country = null;
var selected_country = "WLD";

var exclude = ["AFG", "COD", "LBY", "LCA", "LIE", "LSO", "MCO", "MDA", "NRU", "PRK", "ROU", "SMR", "SOM", "SSD", "SYR", "TLS", "TUV", "WLD"];

var metrics = ["ICGGD with Production Emissions", 
"ICGGD with Consumption Emissions", 
"Consumption CO2 Emissions Annual Change", 
"Consumption CO2 Emissions Absolute Value", 
"Production CO2 Emissions Annual Change",
"Production CO2 Emissions Absolute Value", 
"GDP percent change", 
"GDP",
"life_expectancy_at_birth_total_years_sp_dyn_le00_in", 
"individuals_using_the_internet_of_population_it_net_user_z", 
"employment_to_population_ratio_15_total_modeled_ilo_est", 
"access_to_electricity_of_population_eg_elc_accs_zs", 
"household_final_consumption_expenditure_per_capita_constant_20", 
"merchandise_imports_current_us_tm_val_mrch_cd_wt", 
"industry_value_added_constant_2010_us_nv_ind_totl_kd", 
"net_migration_sm_pop_netm", 
"total_natural_resources_rents_of_gdp_ny_gdp_totl_rt_zs", 
"renewable_energy_consumption_of_total_final_energy_consumpti", 
"urban_population_of_total_sp_urb_totl_in_zs", 
"proportion_of_seats_held_by_women_in_national_parliaments"];

var format = d3.format(".0%");

var default_format = d3.format(",.2r");

var format_si = d3.format(".2s");

function format_abbrev(x) {
  var s = format_si(x);
  switch (s[s.length - 1]) {
    case "G": return s.slice(0, -1) + "B";
  }
  return s;
}

var metric_lookup = {
  "ICGGD with Production Emissions": {
    "key": "ICGGD with Production Emissions",
    "name": "Territorial ICGGD",
    "units": "",
    "scale": "d3.scaleLinear",
    "format": default_format,
    "extent": [-10,9],
    "longextent": [-0.5,3]
  },
  "ICGGD with Consumption Emissions": {
    "key": "ICGGD with Consumption Emissions",
    "name": "Consumption ICGGD",
    "units": "",
    "scale": "d3.scaleLinear",
    "format": default_format,
    "extent": [-7,6],
    "longextent": [-0.5,3]
  },

  "Production CO2 Emissions Annual Change": {
    "key": "Production CO2 Emissions Annual Change",
    "name": "Fossil fuels and cement production emissions by country (territorial, GCB)",
    "units": "change based on Mt C",
    "scale": "d3.scaleLinear",
    "format": format,
    "extent": [-0.3,.3],
    "longextent": [-0.5,3]
  },
  "Production CO2 Emissions Absolute Value": {
    "key": "Production CO2 Emissions Absolute Value",
    "name": "Fossil fuels and cement production emissions by country (territorial, GCB)",
    "units": "Mt C",
    "scale": "d3.scaleLinear",
    "format": default_format,
    "extent": [0,10000],
    "longextent": [-0.5,3]
  },

  "Consumption CO2 Emissions Annual Change": {
    "key": "Consumption CO2 Emissions Annual Change",
    "name": "Consumption emissions (GCB)",
    "units": "change based on Mt C",
    "scale": "d3.scaleLinear",
    "format": format,
    "extent": [-0.3,0.3],
    "longextent": [-0.5,3]
  },
  "Consumption CO2 Emissions Absolute Value": {
    "key": "Consumption CO2 Emissions Absolute Value",
    "name": "Consumption emissions (GCB)",
    "units": "Mt C",
    "scale": "d3.scaleLinear",
    "format": format,
    "extent": [0,2500],
    "longextent": [-0.5,3]
  },

  "GDP percent change": {
    "key": "GDP percent change",
    "name": "Gross Domestic Product (GDP) Change",
    "units": "",
    "scale": "d3.scaleLinear",
    "format": format,
    "extent": [-0.3,0.3],
    "longextent": [-0.5,3]
  },
  "GDP": {
    "key": "GDP",
    "name": "Gross Domestic Product (GDP)",
    "units": "constant 2010 US$",
    "scale": "d3.scaleLinear",
    "format": format_si,
    "extent": [0,2e13],
    "longextent": [1,1e15]
  },

  "life_expectancy_at_birth_total_years_sp_dyn_le00_in": {
    "key": "life_expectancy_at_birth_total_years_sp_dyn_le00_in",
    "name": "Life expectancy at birth, total",
    "units": "years",
    "scale": "d3.scaleLinear",
    "format": default_format
  },
  "individuals_using_the_internet_of_population_it_net_user_z": {
    "key": "individuals_using_the_internet_of_population_it_net_user_z",
    "name": "Individuals using the Internet",
    "units": "of population",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "employment_to_population_ratio_15_total_modeled_ilo_est": {
    "key": "employment_to_population_ratio_15_total_modeled_ilo_est",
    "name": "Employment to population ratio, 15+, total (modeled ILO estimate)",
    "units": "",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "access_to_electricity_of_population_eg_elc_accs_zs": {
    "key": "access_to_electricity_of_population_eg_elc_accs_zs",
    "name": "Access to electricity",
    "units": "of population",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "household_final_consumption_expenditure_per_capita_constant_20": {
    "key": "household_final_consumption_expenditure_per_capita_constant_20",
    "name": "Household final consumption expenditure per capita",
    "units": "constant 2010 US$",
    "scale": "d3.scaleLinear",
    "format": default_format
  },
  "merchandise_imports_current_us_tm_val_mrch_cd_wt": {
    "key": "merchandise_imports_current_us_tm_val_mrch_cd_wt",
    "name": "Merchandise imports",
    "units": "change of current US$",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "industry_value_added_constant_2010_us_nv_ind_totl_kd": {
    "key": "industry_value_added_constant_2010_us_nv_ind_totl_kd",
    "name": "Industry, value added",
    "units": "change of constant 2010 US$",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "net_migration_sm_pop_netm": {
    "key": "net_migration_sm_pop_netm",
    "name": "Net migration",
    "units": "number of persons",
    "scale": "d3.scaleLinear",
    "format": format_abbrev
  },
  "total_natural_resources_rents_of_gdp_ny_gdp_totl_rt_zs": {
    "key": "total_natural_resources_rents_of_gdp_ny_gdp_totl_rt_zs",
    "name": "Total natural resources rents",
    "units": "of GDP",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "renewable_energy_consumption_of_total_final_energy_consumpti": {
    "key": "renewable_energy_consumption_of_total_final_energy_consumpti",
    "name": "Renewable energy consumption",
    "units": "change of share of total final energy consumption",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "urban_population_of_total_sp_urb_totl_in_zs": {
    "key": "urban_population_of_total_sp_urb_totl_in_zs",
    "name": "Urban population",
    "units": "of total",
    "scale": "d3.scaleLinear",
    "format": format
  },
  "proportion_of_seats_held_by_women_in_national_parliaments": {
    "key": "proportion_of_seats_held_by_women_in_national_parliaments",
    "name": "Proportion of seats held by women in national parliaments",
    "units": "of total seats",
    "scale": "d3.scaleLinear",
    "format": format
  }
}

var margin = { top: 50, right: 20, bottom: 50, left: 50 };
var width = 530 - margin.left - margin.right;
var height = 560 - margin.top - margin.bottom;

var lookup = {};

// var tooltip = d3.select("#tooltip");

var map_width = 620;
var map_height = 560;

var svg = d3.select("body")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Label displaying which y-metric is active
    svg.append("text")
      .attr("x", 6)
      .attr("y", -5)
      .attr("class", "label active-ymetric-label")
      // changed this, no longer including (units)
      .text(metric_lookup[active_ymetric].name + ": ")

/*    svg.append("text")
      .attr("x", 6)
      .attr("y", 15)
      .attr("class", "active-ymetric-label-value");*/

      // Label displaying current years being shown
    var year_label = svg.append("text")
      .attr("x", width-2)
      .attr("y", -5)
      .attr("class", "label")
      .attr("text-anchor", "end")
      .style("font-weight", "bold")
      .style("font-size", "36px")
      .text("1999-2000");
      // Label showing which x-metric is active


    svg.append("text")
      .attr("x", width-2)
      .attr("y", height-6)
      .attr("text-anchor", "end")
      .attr("class", "active-metric-label")
      // changed this, no longer including (units)
      .text(metric_lookup[active_metric].name);

    svg.append("text")
      .attr("x", width-2)
      .attr("y", height-20)
      .attr("text-anchor", "end")
      .attr("class", "active-metric-label-value");


var map_container = d3.select("body")
  .append("div")
    .style("width", map_width + "px")
    .style("height", map_height + "px")
    .style("position", "relative")
    .style("display", "inline-block");

d3.selectAll(".mouseover_checkbox")
.on("change", function () { 
    if(this.checked){
      clicked_country = selected_country;
    } else {
      clicked_country = null;
    }
});

d3.selectAll(".autoplay_checkbox")
.on("change", function () { 
    if(this.checked){
      
      playing = true;

      // Is there a timeout in progress?
      // If so, stop it and start a new one
      if(currentTimeout){
        clearTimeout(currentTimeout)
        nextYear();
      }

      return;

    } else {

      playing = false;

      // Don't allow another nextYear() to continue
      if(currentTimeout){
        clearTimeout(currentTimeout)
      }

      return;
    }
});

var map_svg = map_container
  .append("svg")
    .attr("width", map_width)
    .attr("height", map_height);


map_container.append("a")
  .text("Colored by Territorial ICGGD Value")
  .attr("href", "../scatterplot/04_divergence_final.html")
  .style("position", "absolute")
  .style("top", (map_height-40) + "px")
  .style("left", (map_width/2-40) + "px")

d3.select("body")
  .append("h3")
  .attr("class", "country-label")
  .text(function(d) { return "World"; });

var xscale = d3.scaleLinear()
  .domain([-0.5,0.5])
  .range([0,width])
  .clamp("true");

var yscale = d3.scaleLinear()
  .domain([-0.5,0.5])
  .range([height,0])
  .clamp("true");


var radius = d3.scaleSqrt()
  .range([2.5,20])
  .domain([0, 3000]);



// CHECK THIS OUT WITH CARNI, get on brand



var color = d3.scaleThreshold()
  .domain([-0.05, -0.02, 0, 0.05, 0.1])
  .range(["#d73027","#f46d43","#fdae61","#abd9e9","#74add1","#4575b4"]);
  
var colorMap = d3.scaleThreshold()
  .domain([-0.05, 0, 0.5, 0.75, 1])
  .range(["#d73027","#f46d43","#fdae61","#abd9e9","#74add1","#4575b4"]);







var xAxis = d3.axisBottom()
  .tickSize(-height)
  .tickFormat(function(d) {
//    if (d == -0.25) return "<" + format(d);
//    if (d == 0.25) return ">" + format(d);
    return format(d);
  })
  .scale(xscale);

var yAxis = d3.axisLeft()
  .tickFormat(function(d) {
//    if (d == 0) { return "N/A"; }
    return format(d);
  })
  .tickSize(-width)
  .scale(yscale)


/* Map */

var projection = d3.geoTimes()
    .scale((map_width - 4) / (1.5 * Math.PI))
    .translate([map_width / 2, map_height / 2])
    .precision(0.1);

var path = d3.geoPath()
    .projection(projection);

var graticule = d3.geoGraticule();

//var isoLookup = {};
var idLookup = {};

map_svg.append("defs").append("path")
    .datum(graticule.outline())
    .attr("id", "sphere")
    .attr("d", path);

map_svg.append("use")
    .attr("class", "stroke")
    .attr("xlink:href", "#sphere");

map_svg.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");

// This draws the graticule lines
map_svg.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);



// The rest of the code follows this function call
// which ensures the data is loaded before graphing it
d3.queue()
// Annual change
  .defer(d3.csv, "../final-data/All\ Data\ Together.csv")
  .await(function(error, all_data) {

    // Fill in lookup table
    all_data.forEach(function(d) {
      lookup[d["ISO"]] = lookup[d["ISO"]] || {};
      // Check for which indicator here
      lookup[d["ISO"]][d["Indicator"]] = d;
      lookup[d["ISO"]]["name"] = lookup[d["ISO"]]["name"] || d["Country Name"]
    });

  console.log(lookup)
  console.log(all_data)    
    // logic for calculating extent, choosing preset if available
 
    metrics.forEach(function(metric) {

      var data = all_data.filter(function(d) { return d["Indicator"]==metric && d["ISO"] !== "WLD";})
      
      var year_cols = [...Array(1+2015-2000).keys()].map(v => 2000+v).map(u => String(u))
      var joined_data = []
      var year
      for (i = 0; i < year_cols.length; i++){
        year = year_cols[i]
        joined_data = joined_data.concat(d3.extent(data, function(d){return +d[year]}))
      }
      var calculated_extent = d3.extent(joined_data)

      var calculated_long_extent = d3.extent(data, function(d) { return +d["Summary Range"]; })
      
      // perhaps, won't need longextent? so don't set it as it's own variable?
      // preset is the default, if it is not present, will use the calcualted extent / long_extent
      var extent = metric_lookup[metric].extent = metric_lookup[metric].extent || calculated_extent;
      metric_lookup[metric].longextent = metric_lookup[metric].longextent || calculated_long_extent;
      

      var yscale = metric_lookup[metric].yscale = d3.scaleLinear().domain(extent).range([70,6]).clamp(true);
      metric_lookup[metric].scale = d3.scaleLinear().domain(extent).range([0,width]).clamp(true);

    });

      // Starting to set up the Scatterplot
      // grab countries, set axes and tick text location

    // Grab all countries
    var countries = d3.keys(lookup);

    // Draw X axis
    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .attr("class", "x axis")
      .call(xAxis);

    // Place text relative to the X axis
    svg.selectAll(".x.axis text")
      .attr("y", 8);

    // Draw Y Axis
    svg.append("g")
      .attr("transform", "translate(0,0)")
      .attr("class", "y axis")
      .call(yAxis);

    // *QQ* no placing .y.axis text?

    // Drawing middle lines - xaxis and yaxis
    // held constant on xscale(0) or yscale(0)
    svg
      .append("line")
      .attr("class", "dark-line-1")
      .style("stroke", "#777")
      .style("stroke-width", 1)
      .attr("x1", xscale(0))
      .attr("x2", xscale(0))
      .attr("y1", 0)
      .attr("y2", height)

    svg
      .append("line")
      .attr("class", "dark-line-2")
      .style("stroke", "#777")
      .style("stroke-width", 1)
      .attr("x1", 0)
      .attr("x2", width)
      .attr("y1", yscale(0))
      .attr("y2", yscale(0))

      // TO DO
      // Current implementation of clicked_country
      // needs additional logic to stop actions in
      // mouseover and mouseout if there is an active clicked_country
      // EDIT
      // Used if(clicked_country){return clicked_country} to shortcircuit


    // draw bubbles
    var group = svg.selectAll("g.bubble")
      .data(countries.filter(function(d) { 
        // only include those not in the exclude list
        return d && exclude.indexOf(d) == -1;
      }))
      .enter().append("g")
      .sort(function(a,b) {
        // if function returns positive, b was bigger than a
        // used for sorting, defaults to descending
        // sort by absolute carbon amount
        // https://stackoverflow.com/questions/15704128/how-can-i-efficiently-convert-data-from-string-to-int-within-a-d3-method-chain
        // + converts a numeric string into a number
        return +lookup[b]["Production CO2 Emissions Absolute Value"][year].replace(",","") - (+lookup[a]["Production CO2 Emissions Absolute Value"][year].replace(",",""));
      })
      .attr("class", "bubble")
      .attr("transform", function(d) {
        // scale x, y location by value of the x metric in a given year, in country d
        return "translate(" + xscale(+lookup[d][active_metric][year]) + "," + yscale(+lookup[d][active_ymetric][year]) + ")"
      });

    group
      .append("text")
      .attr("y", -20)
      .attr("text-anchor", "middle")
      .style("font-weight", "bold")
      .text(function(d) {
        // Changed this from idLookup to lookup
        return d in lookup ? lookup[d].name : "";
      })
      .style("display", "none");

    group
      .append("circle")
      // the circle gets drawn here... above was only a reference
      // to the center of a bubble element
      .attr("r", function(d) {
        return radius(+lookup[d]["Production CO2 Emissions Absolute Value"][year].replace(",",""));
      })
      .style("fill", function(d) {
        return "#777";
      })
      .on("click", function(d) {
        clicked_country = d
        d3.selectAll(".mouseover_checkbox")
        .property("checked", true)

        update_to_selected_region(clicked_country);
      })
      .on("mouseover", function(d) {
        var country = d;
        if (clicked_country) { 
          //if(country == clicked_country){
          //  revive_tooltip();
          //}
          return clicked_country
        } else {
        // *QQ* the second check may be unnecessary... will it ever be true?
          if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
          if (!(country in lookup)) { return "#eaeaea"; }
          update_to_selected_region(country)
        }
      })
      // Cause tooltip to follow mouse as user moves
      //.on("mousemove", function(d) {
      //  return tooltip.style("top", (d3.event.pageY-52) + "px").style("left", (d3.event.pageX+18) + "px");
      //})
      .on("mouseout", function() {

        // Attempt to short-circuit if there is an active clicked_country
        if (clicked_country) { 
          //kill_tooltip();
          return clicked_country; 
        } else {
          reset_to_global()
        }
      })

    /* Map */

    // TO DO
    // update this to reference the official WRI geojson map bounds
    // check commands which use topojson...

    // *QQ* Convert wri-bounds to topojson? 
    // Does make them smaller, then don't have to chage the add code :)

    // stamen's: world-50m.json
    // wri's: wri-bounds-topo.json
    // wri's: all_primary_countries.json
    d3.json("../data/all_primary_countries.json", function(error, world){
      if (error) throw error;

      map_svg.selectAll("path.country")
        //.data(topojson.feature(world, world.objects.countries).features)
        .data(world.features)
        .enter().append("path")
          .attr("class", "country")
          .attr("d", path);

        // setYear_updateData depends on data and map both being loaded
        // uses idLookup
        setYear_updateData(2000);
        setTimeout(nextYear, 1100);
         console.log("set year and cued nextYear")

        map_svg.selectAll("path.country")
          .style("fill", function(d) {
            var country = d.properties.iso_a3
            if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
            if (!(country in lookup)) { return "#eaeaea"; }
            var datum = lookup[country];
            if (datum[active_ymetric][year] == "") { return "#eaeaea" };

            // TO DO
            // Add logic here to change up which variable is used to color
            var color_var = "ICGGD with Production Emissions"

            // TO DO
            // condense color and colorMap functions into one
            return colorMap(+datum[color_var][year]) || "#eaeaea";
          })
          .on("click", function(d){
            clicked_country = d.properties.iso_a3;
            d3.selectAll(".mouseover_checkbox")
             .property("checked", true)

            reset_to_global();
            update_to_selected_region(clicked_country)
          })
          .on("mouseover", function(d) {
            var country = d.properties.iso_a3
            if (clicked_country) { 
              //if(country == clicked_country){
              //  revive_tooltip();
              //}
              return clicked_country; 
            } else {
              if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
              if (!(country in lookup)) { return "#eaeaea"; }
              update_to_selected_region(country)
            }            
            
          })
          //.on("mousemove", function(d) {
          //  return tooltip.style("top", (d3.event.pageY-52) + "px").style("left", (d3.event.pageX+18) + "px");
          //})
          .on("mouseout", function() {
            if (clicked_country) { 
              //kill_tooltip();
              return clicked_country; 
            } else {
              reset_to_global();
            } 
          });

    // End map load logic
    });

    // Define slider behavior
    // *QQ* May have to move this up
    d3.select("#year-slider")
      .on("input", function() {
        year = this.value;

        // Check for moving to last year
        if (year == 2016) {

          // Map from 2016 to summary periods, account for fact that consumption_co2 doesn't have data for 2015
          // Could get these measures from EORA later
          if (active_metric == "consumption_co2") {
            year = "2000-2014";
          } else {
            year = "2000-2015";
          }

          // Should this just check whether currentTimeout exists?
          // Or stay checking whether next_year_in_progress is on?
          if(currentTimeout){
             next_year_in_progress = false;
             clearTimeout(currentTimeout);
          }
          // if(next_year_in_progress){
          //     next_year_in_progress = false;
          //     clearTimeout(currentTimeout);
          // }

          setYear_updateData(year);
          // don't call nextYear because this is 2016
          //if(playing){
          //  nextYear();
          //}

          return;
        }

        // Slider year is sometime before 2016

        // Autoplay: on
        if(playing){

          // Need to clean the previous Timeout to avoid multiple's starting

          // Should this just check whether currentTimeout exists?
          // Or stay checking whether next_year_in_progress is on?
          if(currentTimeout){
             next_year_in_progress = false;
             clearTimeout(currentTimeout);
          }                
          // if(next_year_in_progress){
          //     next_year_in_progress = false;
          //     clearTimeout(currentTimeout);
          // } 
          
          // Update data labels and visuals
          setYear_updateData(year);

          // Call nextYear() in 1.1 seconds
          currentTimeout = setTimeout(nextYear, 1100);

          return;

        } else {
          // Autoplay: off

          // Should this just check whether currentTimeout exists?
          // Or stay checking whether next_year_in_progress is on?
          if(currentTimeout){
             next_year_in_progress = false;
             clearTimeout(currentTimeout);
          }   
          // if(next_year_in_progress){
          //     next_year_in_progress = false;
          //     clearTimeout(currentTimeout);
          // }

          // Update data labels and visuals
          setYear_updateData(year);

          // Don't Call nextYear(), autoplay is off
          // currentTimeout = setTimeout(nextYear, 1100);

        }
  });

  // End of data load await
});

// HELPER FUNCTIONS


    var currentTimeout;

    function nextYear() {

      next_year_in_progress=true;

      if (!playing) {
        return;
      }

      // Handle case if at end of period
      if(String(year).indexOf("-") > -1){

        // Decide: turn off autoplay, or keep it on?
        // I think leave it on, and don't call next year
        // playing=false;

        next_year_in_progress=false;
        // Can't go on, because year++ would trigger an exception
        // won't be able to increment a string (2000-2014, or 2000-2015)
        return;
      }

      year++;

      // Map 2016 to the summary data for whatever period data is availabl for
      if (year == 2016) {

        if(active_metric == "consumption_co2"){
          // no 2015 data available, so default to period summary
          year = "2000-2014";
        } else {
          year = "2000-2015"
        }

        // update with this year, which will contain a "-" and trigger behavior in setYear_updateData
        setYear_updateData(year);

        // playing stays on, but doesn't call nextYear()
        next_year_in_progress=false;

        return;
      } else if(year < 2016) {
          // Update data
          setYear_updateData(year);
          // trigger nextYear()
          currentTimeout = setTimeout(nextYear, 1100);
        return;
      }
    };





    function updateXScale(active_metric) {

      datum = lookup[selected_country]
      d3.selectAll(".active-metric-label").text(metric_lookup[active_metric].name);
      d3.selectAll(".active-metric-label-value").text(metric_lookup[active_metric].format(+datum[active_metric][year]) + " " + metric_lookup[active_metric].units);

      xscale = metric_lookup[active_metric].scale;

      // for 2000-2015 year ranges
      if (String(year).indexOf("-") > -1 && "longextent" in metric_lookup[active_metric]) {
        xscale.domain(metric_lookup[active_metric].longextent);
      } else {
        xscale.domain(metric_lookup[active_metric].extent);
      }

      var xAxis = d3.axisBottom()
        .tickSize(-height)
        .tickFormat(metric_lookup[active_metric].format)
        .scale(xscale);

      svg.select(".x.axis")
        .transition()
        .call(xAxis);

      d3.selectAll(".dark-line-1")
        .transition()
        .attr("x1", xscale(0))
        .attr("x2", xscale(0))

      svg.selectAll(".x.axis text")
        .transition()
        .attr("y", 8);
    };

    function updateYScale(active_ymetric) {

      datum = lookup[selected_country]
      d3.selectAll(".active-ymetric-label").text(metric_lookup[active_ymetric].name + ": " + metric_lookup[active_ymetric].format(+datum[active_ymetric][year]) + " " + metric_lookup[active_ymetric].units);

      // for 2000-2015 year ranges
      if (String(year).indexOf("-") > -1 && "longextent" in metric_lookup[active_ymetric]) {
        yscale.domain(metric_lookup[active_ymetric].longextent);
      } else {
        yscale.domain(metric_lookup[active_ymetric].extent);
      }

      var yAxis = d3.axisLeft()
         .tickFormat(metric_lookup[active_ymetric].format)
        .tickSize(-width)
        .scale(yscale)

      svg.select(".y.axis")
        .transition()
        .call(yAxis);

      d3.selectAll(".dark-line-2")
        .transition()
        .attr("y1", yscale(0))
        .attr("y2", yscale(0))
    };



    function setYear_updateData(year) {
      var summary_period = true;

      // If year is a range (2000-2014 or 2000-2015)
      if (String(year).indexOf("-") > -1) {
        summary_period = true;

        // Only behave differently with consumption_co2 if it is a summary-year
        if (active_metric == "consumption_co2") {
          year = "2000-2014";
        } else {
          year = "2000-2015";
        }
        year_label.text(year);

        // Reinfoce that the year slider should be at 2016 during this time range, summary selection
        d3.select("#year-slider").node().value = 2016;
      } else {

        // If single year, make label equal to last year - this year
        // update year slider
        // will this trigger loop again?
        year_label.text((year-1) + "-" + year);
        d3.select("#year-slider").node().value = year;
      }
    
      updateXScale(active_metric);
      updateYScale(active_ymetric);
      transition_scatter_and_map();

      // Was UpdateDataValues(), break apart here
      update_labels(); 

    }

    // Creates transitions for dot location & color, map color
    function transition_scatter_and_map() {

      // If 2000-2014, would only be showing 

      svg.selectAll("g.bubble")
        .transition()
        .duration(700)
        .style("opacity", function(d) {
          var both_exist = true;
          if (active_metric in lookup[d] && year in lookup[d][active_metric]) {
            var value = lookup[d][active_metric][year];
            if (value == "") {
              both_exist = false;
            }
          } else {
            both_exist = false;
          }
          if (active_ymetric in lookup[d] && year in lookup[d][active_ymetric]) {
            var value = lookup[d][active_ymetric][year];
            if (value == "") {
              both_exist = false;
            }
          } else {
            both_exist = false;
          }
          return both_exist ? 0.8 : 0;
        })
        .attr("transform", function(d) {
          if (active_metric in lookup[d] && year in lookup[d][active_metric]) {
            var value = lookup[d][active_metric][year];
            var x = value == "" ? 0 : xscale(+value);
          } else {
            var x = 0;
          }
          return "translate(" + x + "," + yscale(+lookup[d][active_ymetric][year]) + ")"
        });

      svg.selectAll("g.bubble circle")
        .transition()
        .duration(700)
        .attr("r", function(d) {
          // if no data, return previous radius
          if (!(year in lookup[d]["Production CO2 Emissions Absolute Value"])) { return d3.select(this).attr("r"); }
          return radius(+lookup[d]["Production CO2 Emissions Absolute Value"][year].replace(",","")) || 2;
        })
        .style("fill", function(d) {
          if (lookup[d][active_ymetric][year] == "") { return "#eaeaea" };
          return color(+lookup[d][active_ymetric][year]) || "#eaeaea";
        })
      map_svg.selectAll("path.country")
        .transition(700)
        .style("fill", function(d) {

          var country = d.properties.iso_a3

          //if (!(d.id in isoLookup)) { return "#eaeaea"; }
          //var country = isoLookup[d.id]["alpha-3"];
          
          if (exclude.indexOf(country) > -1) { return "#eaeaea"; }
          if (!(country in lookup)) { return "#eaeaea"; }
          var datum = lookup[country];
          if (datum[active_ymetric][year] == "") { return "#eaeaea" };
          return colorMap(+datum["ICGGD with Production Emissions"][year]) || "#eaeaea";
        })
    }

    function update_to_selected_region(region_name) {

        reset_to_global();
        // set global variable to new selected region
        selected_country = region_name

        update_map();
        console.log("Updated map")

        update_circles();
        console.log("Updated circles")

        update_labels(); 
        console.log("Updated labels")
    }

function reset_to_global(){
          // Reselect global extent, update text
            selected_country = "WLD";
            d3.selectAll(".country-label").text("World");
            update_labels();
            
            // set all countries back to focus
            map_svg.selectAll("path.country")
              .style("opacity", 1)
              .style("stroke", null);

            // de-highlight all circles
            svg.selectAll(".bubble circle")
              .style("stroke", null)
              .style("stroke-width", null);

            // turn off displaying the bubble's text
            svg.selectAll(".bubble text")
              .style("display", "none");

            // hides the tooltip
            //tooltip.style("display", "none");

}

/*
function kill_tooltip(){
    // hides the tooltip
    tooltip.style("display", "none");
}
function revive_tooltip(){
    // hides the tooltip
    tooltip.style("display", null);
}
*/

function update_labels(){

        // change labels to be mousedover country's name

        // if lookup had the country name, wouldn't need idLookup here

        country_name = lookup[selected_country].name
        d3.selectAll(".country-label").text(country_name); 


        // clear tooltip, change header name
        
        // TAKING OUT THE TOOL TIP
        // tooltip.style("display", null).html("");
        // tooltip.append("h3").text(country_name);

        // grab country's data, populate tooltip
        var datum = lookup[selected_country];
        d3.keys(datum).forEach(function(metric) {

          if (datum[metric][year] && ((metric == active_ymetric) || (metric == active_metric)) ) {

            //console.log("appending to tooltip")
            //var div = tooltip.append("div");
            //div.append("span").text(metric_lookup[metric].name + ": ");
            //div.append("span").text(metric_lookup[metric].format(+datum[metric][year]));
            //div.append("span").text(" " + metric_lookup[metric].units);

            if(metric == active_metric){
              // Update the value next to the x-axis label
              d3.select(".active-metric-label").
              text(metric_lookup[metric].name + ": ") 
              d3.select(".active-metric-label-value")
              .text(metric_lookup[metric].format(+datum[metric][year]) + " " + metric_lookup[metric].units);
            } else {
              // is equal to active_ymetric
              // Update value next to the y-axis label
              d3.selectAll(".active-ymetric-label").text(metric_lookup[active_ymetric].name + ": " + metric_lookup[active_ymetric].format(+datum[active_ymetric][year]) + " " + metric_lookup[active_ymetric].units);
            }

          }
        });
}



function update_circles(){
            // uses the .raise() function to bring a point above others
        svg.selectAll(".bubble")
          .filter(function(p) {
            return selected_country == p;
          })
          .raise();

            // TO DO
            // implement a re-sort of the scatter points so that the small
            // points don't get covered by bigger ones which had been previously selected


        // setting style of circle to show bold line around circumference, display country name text
            var selected_bubble = svg.selectAll(".bubble")
              .filter(function(p) {
                return selected_country == p;
              })
              .raise();

            selected_bubble.select("circle")
              .style("stroke", "#111")
              .style("stroke-width", "2px");
            
            // only put label over the scatter dot if map country is selected
              selected_bubble.select("text")
                .style("display", null);
}
function update_map(){
          // redraw the map to highlight the country being mousedover
        map_svg.selectAll("path.country")
          .style("opacity", function(p) {
            //return p.properties.iso_a3 == String(+idLookup[selected_country]["country-code"]) ? 1 : 0.3;
            return p.properties.iso_a3 == String(selected_country) ? 1 : 0.3;

          })
          .style("stroke", function(p) {
            //return p.properties.iso_a3 == String(+idLookup[selected_country]["country-code"]) ? "#222" : null;
            return p.properties.iso_a3 == String(selected_country) ? "#222" : null;
          });
}



</script>
